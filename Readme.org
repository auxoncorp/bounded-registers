#+TITLE:  Registers

A high-assurance register code generation and interaction library.

* Install

#+BEGIN_SRC shell
$ git clone git@github.com:auxoncorp/registers.git
$ cd registers && cargo install
#+END_SRC

* Use

There are two core pieces to ~registers~:

** I. The macro

#+BEGIN_SRC rust
#[macro_use] // register! leans on typenum's op! macro.
extern crate typenum;
#[macro_use]
extern crate registers;

use typenum::consts::U1;

use registers::ReadWriteRegister;

register! {
    Status,
    RW,
    Fields [
        On WIDTH(U1) OFFSET(U0),
        Dead WIDTH(U1) OFFSET(U1),
        Color WIDTH(U3) OFFSET(U2) [
            Red = U1,
            Blue = U2,
            Green = U3,
            Yellow = U4
        ]
    ]
}
#+END_SRC

The ~register!~ macro generates the code necessary for ergonomic
register access and manipulation. The expected input for the macro is
as follows:
1. The register name.
2. Its mode, either ~RO~ (read only), ~RW~ (read write), or ~WO~
   (write only).
3. The register's fields, beginning with ~Fields [~, and then a
   closing ~]~ at the end.

A field constists of its name, its width, and its offset within the
register. Optionally, one may also state enum-like key/value pairs for
the values of the field, nested within the field declaration with
~[]~'s

The code which this macro generates is a tree of nested modules where
the root is a module called ~$register_name~. Within ~$register_name~,
there will be the register itself, as ~$register_name::Register~, as
well as a child module for each field.

Within each field module, one can find the field itself, as
~$register_name::$field_name::Field~, as well as a few helpful aliases
and constants.

- ~$register_name::$field_name::Read~: In order to read a field, an
  instance of that field must be given to have access to its mask and
  offset. ~Read~ can be used as an argument to ~get_field~ so one does
  not have to construct an arbitrary one when doing a read.
- ~$register_name::$field_name::Clear~: A field whose value is
  zero. Passing it to ~modify~ will clear that field in the register.
- ~$register_name::$field_name::Set~: A field whose value is
  ~$field_max~.  Passing it to ~modify~ will set that field to its max
  value in the register. This is useful particularly in the case of
  single-bit wide fields.
- ~$register_name::$field_name::$enum_kvs~: constants mapping the enum
  like field names to values.

** II. Interacting with registers

*** Through a constructor

#+BEGIN_SRC rust
fn main() {
    let mut reg = Status::Register::new(0);
    reg.modify(Status::Dead::Field::Set);
    assert_eq!(reg.read(), 2);
}
#+END_SRC

In this example, we initialize a register with the value ~0~ and then
set the ~Dead~ bit—the second field—which should produce the value ~2~
when interpreting this word-sized register as a ~u32~.

*** Through a register block

Here we take a known address, one we may find in a developer's manual,
and interpret that address as a register block. We can then
dereference that pointer and use the register API to access the
registers in the block.

#+BEGIN_SRC rust
register! {
    UartRX,
    RO,
    Fields [
        Data        WIDTH(U8) OFFSET(U0),
        ParityError WIDTH(U1) OFFSET(U10),
        Brk         WIDTH(U1) OFFSET(U11),
        FrameError  WIDTH(U1) OFFSET(U12),
        Overrrun    WIDTH(U1) OFFSET(U13),
        Error       WIDTH(U1) OFFSET(U14),
        ChrRdy      WIDTH(U1) OFFSET(U15)
    ]
}

register! {
    UartTX,
    WO,
    Fields [
        Data WIDTH(U8) OFFSET(U0)
    ]
}

register! {
    UartControl1,
    RW,
    Fields [
        Enable              WIDTH(U1) OFFSET(U0),
        Doze                WIDTH(U1) OFFSET(U1),
        AgingDMATimerEnable WIDTH(U1) OFFSET(U2),
        TxRdyDMAENable      WIDTH(U1) OFFSET(U3),
        SendBreak           WIDTH(U1) OFFSET(U4),
        RTSDeltaInterrupt   WIDTH(U1) OFFSET(U5),
        TxEmptyInterrupt    WIDTH(U1) OFFSET(U6),
        Infrared            WIDTH(U1) OFFSET(U7),
        RecvReadyDMA        WIDTH(U1) OFFSET(U8),
        RecvReadyInterrupt  WIDTH(U1) OFFSET(U9),
        IdleCondition       WIDTH(U2) OFFSET(U10),
        IdleInterrupt       WIDTH(U1) OFFSET(U12),
        TxReadyInterrupt    WIDTH(U1) OFFSET(U13),
        AutoBaud            WIDTH(U1) OFFSET(U14),
        AutoBaudInterrupt   WIDTH(U1) OFFSET(U15)
    ]
}


/// This register lives at 0xDEADBEEF
#[repr(C)]
struct UartBlock {
    rx: UartRX::Register,
    _padding1: [u32; 15],
    tx: UartTX::Register,
    _padding2: [u32; 15],
    control1: UartControl1::Register,
}

fn main() {
    let ub = 0xDEADBEEF_usize as *mut UartBlock;

    unsafe {
        (*ub)
            .control1
            .modify(UartControl1::RecvReadyInterrupt::Field::checked::<U1>());
    }
}
#+END_SRC

* Theory

~registers~ employs values—specifically numbers—at the type-level in
order to get compile time assertions on interactions with a
register. Each field's width is used to determine a maximum value, and
then reading from and writing to those fields is either checked at
compile time, through the ~checked~ function, or is expected to
/carry/ a proof, which uses the aforementioned bound to construct a
value at runtime which is known to not contravene it.
